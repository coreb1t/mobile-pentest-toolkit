#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
import sys


from urllib.request import urlopen

from colorama import Fore, Back, Style
from mpt import logger
from mpt import settings
from mpt.functions import *


__version__ = '0.4.9'


def yes_no(answer):
    yes = set(['yes', 'y', 'ye', ''])
    no = set(['no', 'n'])

    while True:
        choice = input(answer).lower()
        if len(choice) == 0:
            print("Please respond with 'yes' or 'no'\n")
        elif choice in yes:
            return True
        elif choice in no:
            return False
        else:
            print ("Please respond with 'yes' or 'no'\n")


def print_config():
    run_as(user='user')

    cfg_path = os.path.join(settings.HOME_FOLDER, settings.CONFIG)

    if os.path.isfile(cfg_path):
        config = ('pentest-dir', 'app', 'package-name', 'proxy-host', 'proxy-port')
        print('config' + ":\t\t" + cfg_path)
        for conf in config:
            space = ''
            if len(conf) < 6:
                space = '\t'
            print(conf + ":\t" + space + load_settings(conf))

    else:
        log.error('Config file {} does not exist. Run --setup'.format(cfg_path))




def setup_pentest(apk):
    run_as(user='user')
    check_adb_device()


    apk_file = ''.join(apk)
    if os.path.isfile(apk_file):

        if not (apk_file.endswith('.apk') or apk_file.endswith('.APK')):
            log.error('File does not have required extension: apk')
            sys.exit()

        log.info('Installing apk file: {}'.format(apk_file))
        # install application
        sp = subprocess.Popen('adb install {}'.format(apk_file), shell=True, stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE, universal_newlines=True)
        sp.communicate()
        # install second time to cause error message
        sp = subprocess.Popen('adb install {}'.format(apk_file), shell=True, stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE, universal_newlines=True)
        out, err = sp.communicate()

        # extract package name from error message
        package = err.split('to re-install ')[1].split(' without first')[0]

        cfg_path = os.path.join(settings.HOME_FOLDER, settings.CONFIG)
        pentest_path = os.path.join(os.getcwd(), settings.PENTEST_FOLDER)
        if os.path.isfile(cfg_path):
            os.remove(cfg_path)


        # remove pentest folder
        if os.path.isdir(pentest_path):
            ans = yes_no('Remove regular folder {} [Yes|No]? '.format(settings.PENTEST_FOLDER))
            if ans:
                shutil.rmtree(pentest_path)
            else:
                log.warn("Folder {} exists. Skip setup".format(settings.PENTEST_FOLDER))
                sys.exit()

        os.makedirs(os.path.join(pentest_path, settings.APP_FOLDER))
        os.makedirs(os.path.join(pentest_path, settings.BACKUP_FOLDER))
        if not os.path.isdir(pentest_path):
            log.error("Error: folder {} could not be created".format(pentest_path))
            sys.exit()
        # TODO print message before overwriting the folder
        log.info("Folder for security assessment {} created".format(Fore.CYAN + settings.PENTEST_FOLDER + Style.RESET_ALL))
        app_name = os.path.join(settings.APP_FOLDER, os.path.basename(apk_file))
        shutil.copy(apk_file, os.path.join(pentest_path,app_name))

        cfg_file = open(cfg_path, 'w')
        cfg_file.write('pentest-dir: {}\n'.format(pentest_path))
        cfg_file.write('app: {}\n'.format(app_name))
        cfg_file.write('package-name: {}\n'.format(package))
        cfg_file.write('proxy-host: {}\n'.format(settings.PROXY_SERVER))
        cfg_file.write('proxy-port: {}\n'.format(settings.PROXY_PORT))
        cfg_file.close()
        #log.info("Configuration file {} created".format(settings.CONFIG))
        log.info('Configuration file {} updated'.format(cfg_path))
    else:
        log.error('File {} does not exist'.format(apk_file))


#TODO remove
def cd_pentest_folder():
    run_as(user='user')

    print('pentest')
    pentest_dir = load_settings('pentest-dir')
    cmd = 'cd ' + pentest_dir + "/"
    print(cmd)

    if os.path.isdir(pentest_dir):
        subprocess.call(cmd ,shell=True)
        #run_interactive_command(cmd)
    else:
        log.error('Pentest Folder {} does not exist'.format(pentest_dir))



def run_adb():
    run_as(user='user')

    returncode = run_command('adb --version | grep -i version', returncode=True)

    if returncode != 0:
        log.error('adb is not installed. Please install package android-sdk-platform-tools '
                  'or add {} to your $PATH variable'.format(os.path.join(settings.MOBILE_FOLDER, "platform-tools")))
        sys.exit(returncode)

    adb_bin = settings.ANDROID_TOOLS['adb']['bin']

    log.info('Executing: {} start-server'.format(adb_bin))
    run_command('sudo {} kill-server'.format(adb_bin), returncode=True)
    # run_command('sudo killall adb')
    run_command('sudo {} start-server'.format(adb_bin))
    output = run_command("{} devices -l".format(adb_bin), print_output=True)

    if not (''.join(output)).find('product') > 0:
        log.error("Run command: sudo {0} kill-server; sudo killall adb; sudo {0} start-server".format(adb_bin))


def list_packages(show_all_pkgs):
    run_as(user='user')
    check_adb_device()
    print_all = False

    if show_all_pkgs == 'all':
        print_all = True

    if print_all:
        log.info('Print all installed packages')
    else:
        log.info('Only user apps are listed. ' + Style.BRIGHT + Fore.WHITE + 'Use option \'-l all\' to display all packages.' + Style.RESET_ALL  )

    packages = run_command(command="""adb shell 'pm list packages -f' | cut -d ":" -f 2""",
                           print_output=False)

    for p in sorted(packages):

        package = p.rstrip("\n\r").split(".apk=")
        package[0] = package[0] + ".apk"

        # print user packages in bold
        if package[0].find('/data/app/') >= 0:
            package[0] = Style.BRIGHT + package[0] + Style.RESET_ALL

        # print all apps including system
        if print_all:
            sys.stdout.write(Fore.CYAN + package[1] + Style.RESET_ALL + "\n" + "[APP]: " + package[0] + "\n")

        # print only user apps
        else:
            if package[0].find('/data/app/') >= 0:
                sys.stdout.write(Fore.CYAN + package[1] + Style.RESET_ALL + "\n" + "[APP]: " + package[0] + "\n")

        # run_command(command="""adb shell 'pm list packages -f' | sed -e 's/.*=//' | sort""", print_output=False)


def run_pidcat(package_name):
    run_as(user='user')
    check_adb_device()

    if not package_name:
        package_name = load_settings('package-name')

    app_installed(package_name)

    tool_name = 'pidcat'
    width_left = 30
    pidcat_bin = settings.ANDROID_TOOLS[tool_name]['bin']

    run_command(command='python2 -u  {} -w {} {}'.format(pidcat_bin, width_left, package_name), print_output=True,
                universal_newlines=True)

def backup_app(package_name):
    run_as(user='user')
    check_adb_device()
    abe_bin = settings.ANDROID_TOOLS['abe']['bin']
    app_tar = "backup.tar"
    adb_backup = "backup.ab"

    if not package_name:
        package_name = load_settings('package-name')

    app_installed(package_name)
    log.info('Backing up application {}'.format(package_name))

    print("Enter your comment for backup (optional):")
    for comment in sys.stdin:
        comment = comment.strip("\n")
        break
    log.debug("comment: {} , len = {}".format(comment, len(comment)))

    # find next folder index
    for index in range(1, 100):
        if len(comment) > 0:
            dirname = 'backup{}_{}_{}'.format(index,package_name, comment)
        else:
            dirname = 'backup{}_{}'.format(index, package_name)
        pentest_dir = load_settings('pentest-dir')
        backup_dir = os.path.join(pentest_dir, settings.BACKUP_FOLDER, dirname)

        # list directories
        dirs = ''.join(os.listdir(os.path.join(pentest_dir, settings.BACKUP_FOLDER)))

        # check if backup<index> folder does not exist
        if dirs.find( "backup" + str(index) ) < 0:
            # backup_dir =  backup<last_index>
            log.info('Backup folder: {}'.format(backup_dir))
            break

    #TODO check whether backup is allowed: <application android:allowBackup="true"

    #TODO automated clicking on button backup my data
    # adb shell input text 0000       # enter password 0000
    # adb shell 'dumpsys window displays | grep cur='
    # init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1794x1731

    print("Please enter password 0000 on the device")
    backup_dir_tmp = backup_dir + '_tmp'
    os.makedirs(backup_dir_tmp)
    backup_file = os.path.join(backup_dir_tmp, adb_backup)
    app_tar = os.path.join(backup_dir_tmp, app_tar)
    run_command('adb backup -app -f {0} {1}'.format(backup_file, package_name))

    log.debug("tar file: " + app_tar)
    log.info('Unpacking backup file')
    run_command(command='java -jar {} unpack {} {} 0000 &> /dev/null'.format(abe_bin, backup_file , app_tar),
                print_output=True)

    file_list = run_command(command='tar -tvf {}'.format(app_tar), return_output=True)

    if not file_list:
        log.error("Backup file {} is empty. Maybe the application is compiled with android:allowBackup=\"false\""
                  .format(os.path.basename(app_tar)))
        shutil.rmtree(backup_dir_tmp)
        sys.exit()

    run_command(command='tar xf {} -C {}'.format(app_tar, backup_dir_tmp), print_output=True)


    # move files to backup folder
    shutil.copytree( os.path.join(backup_dir_tmp + '/apps/' + package_name  + '/'), backup_dir)

    files = {'db': 'databases',
             'f': 'files',
             'sp': 'shared_prefs',
             'ef': 'external_storage_files',
             'r': 'root'}
    # rename files
    for key in files.keys():
        if os.path.isdir(os.path.join(backup_dir, key)):
            shutil.move(os.path.join(backup_dir, key), os.path.join(backup_dir, files[key]))

    shutil.rmtree(backup_dir_tmp)


def get_jar_file():
    """
    :return converted jar from APP_FOLDER:
    """
    app_dir = os.path.join(load_settings('pentest-dir'), settings.APP_FOLDER)
    jar_file = ""
    for file in os.listdir(app_dir):
        if file.endswith(".jar"):
            jar_file = file
    return jar_file

def run_decompiler():
    run_as(user='user')

    decompiler = settings.ANDROID_TOOLS[settings.DECOMPILER]['bin']
    app_dir = os.path.join(load_settings('pentest-dir'), settings.APP_FOLDER)
    apk_file = load_settings('app')
    jar_file = get_jar_file()

    if not jar_file:
        code = run_command('cd {}; d2j-dex2jar {}'.format(app_dir, os.path.basename(apk_file)),
                           returncode=True, return_output=False)
        if code != 0:
            log.error('Converting dex to class files using dex2jar failed')
    jar_file = get_jar_file()
    log.info("Default decompiler: " + settings.DECOMPILER)
    run_command('cd {}; java -jar {} {}'.format(app_dir, decompiler, jar_file), print_output=True)



def run_frida():
    run_as(user='user')
    check_adb_device()

    # determine architecture for available frida-server binary
    bin_arch = ''
    if os.path.exists(settings.FRIDA_BIN):
        if run_command(command='file {} | grep -i arm | grep 64'.format(settings.FRIDA_BIN)):
            bin_arch = 'arm64'
        elif run_command(command='file {} | grep -i arm | grep 32'.format(settings.FRIDA_BIN)):
            bin_arch = 'arm'
        elif run_command(command='file {} | grep -i elf | grep 64'.format(settings.FRIDA_BIN)):
            bin_arch = 'x86_64'
        elif run_command(command='file {} | grep -i elf | grep 32'.format(settings.FRIDA_BIN)):
            bin_arch = 'x86'

    arch = get_device_architecture()

    # remove frida binary if it is not match on arch
    if arch != bin_arch and bin_arch and os.path.isfile(settings.FRIDA_BIN):
        os.remove(settings.FRIDA_BIN)
        log.warn("Wrong architecture, {} removed".format(settings.FRIDA_BIN))

    # download frida-server binary
    if not os.path.exists(settings.FRIDA_BIN):
        download_frida(arch)
    else:
        log.info('File {} [{}] exists, skip downloading'.format(settings.FRIDA_BIN, arch))


    id = get_shell_user_id()
    log.info('adb shell is running as {}'.format(id))

    kill_process_by_name('frida-server')
    kill_process_by_name('frida-helper')

    # run frida
    run_command(command='adb forward tcp:27042 tcp:27042', print_output=True)
    run_command(command='adb push {} /data/local/tmp/'.format(settings.FRIDA_BIN), print_output=False)
    run_command(command='adb shell "chmod 755 /data/local/tmp/{}"'.format(settings.FRIDA_BIN), print_output=True)
    rversion = run_command(command='adb shell "/data/local/tmp/{} --version"'
                           .format(settings.FRIDA_BIN), print_output=False)[0].replace('\n', '')
    lversion = run_command('frida-ps --version')[0].replace('\n', '')

    log.info('Frida remote version: {}'.format(rversion))
    log.info('Frida local version:  {}'.format(lversion))
    if rversion != lversion:
        log.warn('Frida versions do not match')

    log.info('Executing {}adb shell /data/local/tmp/{}'.format(Style.BRIGHT, settings.FRIDA_BIN + Style.RESET_ALL))

    # adb shell running as root (virtual device)
    if id.find('uid=0(root)') >= 0:
        command = """adb shell \"/data/local/tmp/{}\" &""".format(settings.FRIDA_BIN)
    # adb shell running as user (physical device)
    else:
        command = """adb shell "su -c \"/data/local/tmp/{}\"\" &""".format(settings.FRIDA_BIN)

    subprocess.Popen(command, shell=True, stdin=None, stdout=None, stderr=None, close_fds=True)

    check_frida_is_running()



def run_mobile_security_framework():
    run_as(user='user')
    virtenv = "mobSF-env"
    framework_dir ='mobSF'

    venv_path = os.path.join(settings.MOBILE_FOLDER, framework_dir, virtenv)

    # create virtual env if not exists
    if not os.path.exists(venv_path):
        log.info("Creating new virtual enviroment: {}".format(venv_path))
        run_command(command='python3 -m venv {}'.format(venv_path), print_output=True)

        reqs_path = os.path.join(settings.MOBILE_FOLDER, framework_dir, 'requirements.txt')
        run_command(command='cd {}; . bin/activate; pip3 install -r {}'.format(venv_path, reqs_path), print_output=True)
        run_command(command='cd {}; . bin/activate; python3 ../manage.py makemigrations'.format(venv_path, reqs_path), print_output=True)
        run_command(command='cd {}; . bin/activate; python3 ../manage.py migrate'.format(venv_path, reqs_path), print_output=True)

    log.info('Starting MobSF server at http://127.0.0.1:8000/')
    run_command(command='cd {}; . bin/activate; python3 ../manage.py runserver'.format(venv_path), print_output=True)


    # TODO remove if version 1.0  properly works
    """
    # MobSF 0.9 with python2 only support
    virt_wrapper = ""
    if os.path.isfile('/usr/local/bin/virtualenvwrapper.sh'):
        virt_wrapper = '/usr/local/bin/virtualenvwrapper.sh'
    else:
        if  os.path.isfile('/usr/bin/virtualenvwrapper.sh'):
            virt_wrapper = '/usr/bin/virtualenvwrapper.sh';

    if not virt_wrapper:
        log.error('Python virtualenvwrapper is not installed')
        sys.exit()


    mobsf_path = os.path.join(settings.MOBILE_FOLDER, framework_dir)
    rerurn_code = run_command(command='source {}; allvirtualenv | grep -w {}'.format(virt_wrapper, virtenv), returncode=True)

    cmd = 'source {}; cd {}; workon {}; '.format(virt_wrapper, mobsf_path, virtenv)
    if rerurn_code != 0:
        log.info("Creating new virtual enviroment: {}".format(virtenv))
        run_command(command='source {}; cd {}; mkvirtualenv --python=/usr/bin/python2 {}'.format(virt_wrapper, mobsf_path, virtenv), print_output=True)
        run_command(command='{} pip install -r requirements.txt'.format(cmd), print_output=True)

    run_command(command='{} python manage.py runserver'.format(cmd), print_output=True)
    """




def run_inspeckage():
    run_as(user='user')
    check_adb_device()
    app_installed('mobi.acpm.inspeckage')

    url =  'http://127.0.0.1:8008'
    run_command(command='adb forward tcp:8008 tcp:8008', print_output=True)

    # check if drozer server is running
    returncode = run_command(command='curl -I -s {}'.format(url), returncode=True)

    if returncode != 0:
        log.error('Could not connect to the Inspeckage server. Please start inspeckage app on your mobile phone and chouse target application')
        sys.exit(returncode)

    run_command(command=' {} {}'.format(settings.BROWSER, url), returncode=True)



def run_drozer():
    run_as(user='user')
    check_adb_device()
    app_installed('com.mwr.dz') # drozer app

    run_command(command='adb forward tcp:31415 tcp:31415', print_output=True)

    # check if drozer server is running
    returncode = run_command(command='adb shell netstat -ltp | grep \'mwr.dz\' | grep 31415', returncode=True)

    if returncode != 0:
        log.error('Could not connect to the drozer server. Please start drozer agent on your mobile phone')
        sys.exit(returncode)

    run_interactive_command('drozer console connect')


def toggle_proxy():
    run_as(user='user')
    check_adb_device()

    proxy_port = load_settings('')
    proxy_host = load_settings('')

    proxy_check = run_command(command='adb shell settings get global http_proxy')[0].replace('\n', '')
    if proxy_check == 'null':
        run_command(command='adb shell settings put global http_proxy {}:{}'
                    .format(settings['proxy-host'], settings['proxy-port']))
        log.success('[+] Proxy enabled: {}:{}'.format(settings['proxy-host'], settings['proxy-port']))
    else:
        run_command(command='adb shell settings delete global http_proxy > /dev/null')
        log.success("[+] Proxy disabled")


def run_frida_script(package_name, frida_script):
    """
    :param package_name: Android package name
    :param frida_script: frida scirpt file location
    :return: None
    """

    run_as(user='user')
    check_adb_device()

    log.debug('pwd: ' + settings.MPT_PATH)
    frida_script = os.path.join(settings.MPT_PATH, frida_script)

    if not package_name:
        package_name = load_settings('package-name')

    app_installed(package_name)
    check_frida_is_running()

    if os.path.isfile(frida_script):

        log.info("Frida script {} loaded\n".format(os.path.basename(frida_script)))
        run_interactive_command(command='frida -R -f {} -l {} --no-pause'.format(package_name, frida_script))
    else:
        log.error('File not found: {}'.format(frida_script))


def disable_ssl_pinning(package_name):

    log.info("Disabling SSL Pinning: " + Fore.CYAN + package_name + Style.RESET_ALL)
    frida_script = "scripts/frida/frida-sslpinning-disable.js"
    frida_script = os.path.join(settings.MPT_PATH, frida_script)

    run_frida_script(package_name, frida_script)


def disable_root_detection(package_name):

    log.info("Disabling Root Detection: " + Fore.CYAN + package_name + Style.RESET_ALL)
    frida_script = "scripts/frida/frida-bypass-root-detection.js"
    frida_script = os.path.join(settings.MPT_PATH, frida_script)

    run_frida_script(package_name, frida_script)



def lower_list(l):
    return [x.lower() for x in l]


def start_appmon(package_name):
    run_as(user='user')
    check_adb_device()
    pip_packages = ['frida', 'flask', 'termcolor', 'dataset', 'htmlentities']
    setting_package = "package-name"
    appmon_folder = "appmon"

    installed_packages = run_command(command='python -m pip freeze')
    installed_packages = [x.replace('\n', '').split('==')[0] for x in installed_packages]

    not_installed_pkgs = set(lower_list(pip_packages)) - set(lower_list(installed_packages))

    if not_installed_pkgs:
        log.error("Please install required packages: {}".format(not_installed_pkgs))
        sys.exit()

    if not package_name:
        check_setting(setting_name=setting_package)
        settings = read_settings()
        package_name = settings['package-name']

    log.info('[+] Inspected app: {}'.format(package_name))

    appmon_path = os.path.join(settings.MOBILE_FOLDER, appmon_folder)
    appmon_executable = os.path.join(appmon_path, 'appmon.py')

    check_frida_is_running()
    log.info("[+] Starting appmon sniffer")
    run_command(command='python2 {} -p android -s {} -a {}'
                .format(appmon_executable, os.path.join(appmon_path, 'scripts/Android'), package_name),
                print_output=True)




def print_banner():
    banner = """{}                        __    _ __                            __            __        __              ____   _ __ 
       ____ ___   ___  / /_  (_) /__        ____  ___  ____  / /____  _____/ /_      / /_____  ____  / / /__(_) /_
      / __ \`__ \/__ \/ __ \/ / / _ \______/ __ \/ _ \/ __ \/ __/ _ \/ ___/ __/_____/ __/ __ \/ __ \/ / //_/ / __/
     / / / / / / /_/ / /_/ / / /  __/_____/ /_/ /  __/ / / / /_/  __(__  ) /_/_____/ /_/ /_/ / /_/ / / ,< / / /_  
    /_/ /_/ /_/\____/_.___/_/_/\___/     / .___/\___/_/ /_/\__/\___/____/\__/      \__/\____/\____/_/_/|_/_/\__/  
                                        /_/                 
    {}
    Written by @coreb1t
    Version: {}
    """.format(Fore.GREEN,Style.RESET_ALL,__version__)
    print(banner)


def cli():

    parser = argparse.ArgumentParser(description=print_banner())

    global log
    log = logger.getLogger()

    parser.add_argument('--setup', metavar='[APK]', nargs=1, type=str,
                        help='setup pentest environment')
    parser.add_argument('--config', help='show current pentest config', action='store_true')
    #parser.add_argument('--pf', help='open pentest folder', action='store_true')
    parser.add_argument('-i', '--install',metavar='tools|apps', nargs='?', type=str, const='', help='Install required packages')
    parser.add_argument('-a', '--adb-run', help='Start adb server', action='store_true')
    parser.add_argument('-l', '--list-packages', metavar='all', nargs='?', type=str, const='',
                        help='Show all installed packages (use option \'all\' to display system apps)')
    parser.add_argument('-p', '--pidcat',metavar='package-name', nargs='?', type=str, const='', help='Show colored logcat for a specific'
                                                                              ' application (<package name> optional)')
    parser.add_argument('-b', '--backup',metavar='package-name', nargs='?', type=str, const='', help='Backup an android application'
                                               ' \n (<package name> optional)')
    parser.add_argument('-c', '--source', help='Start java decompiler for course code analysis', action='store_true')
    parser.add_argument('-f', '--frida', help='Run frida server on the device', action='store_true')
    parser.add_argument('-e', '--inspeckage', help='Open Inspeckage web interface', action='store_true')
    parser.add_argument('-m', '--mobile-sec-framework', help='Run Mobile Security Framework (MobSF)',
                        action='store_true')
    parser.add_argument('-d', '--drozer', help='Run drozer application', action='store_true')
    parser.add_argument('-w', '--wifi-proxy', help='Enable/Disable WiFi Proxy"', action='store_true')
    parser.add_argument('-s', '--ssl-pinning',metavar='package-name', nargs='?', type=str, const='',
                        help='Disable SSL Pinning (<package name> optional)')
    parser.add_argument('-r', '--root-detection', metavar='package-name', nargs='?', type=str, const='',
                        help='Disable Root Detection (<package name> optional)')
    #parser.add_argument('-n', '--start-appmon', nargs='?', type=str, const='',
    #                    help='Start Appmon - Sniffer (<package name> optional)',
    #                    metavar='package name')


    if (len(sys.argv) == 1):
        parser.print_usage()
        sys.exit()
        """
        log.success('test')
        log.warning('test')
        log.error('ssss')
        log.critical('ssss')
        log.info('Usage')
        """


    args = parser.parse_args()

    if args.config:
        print_config()
    if args.setup or type(args.setup) is str :
        setup_pentest(apk=args.setup)  # done
    #if args.pf: # pentest folder
    #    cd_pentest_folder()
    if args.install or type(args.install) is str :
        install_packages(install=args.install)  # done
    if args.adb_run:
        run_adb()           # done
    if args.list_packages or type(args.list_packages) is str :
        list_packages(show_all_pkgs=args.list_packages)     # done
    if args.pidcat or type(args.pidcat) is str:
        run_pidcat(package_name=args.pidcat)        # done
    if args.backup or type(args.backup) is str:
        backup_app(package_name=args.backup)        # done
    if args.source:
        run_decompiler()         # done
    if args.frida:
        run_frida()         # done
    if args.mobile_sec_framework:
        run_mobile_security_framework() #done
    if args.inspeckage:
        run_inspeckage()    # done
    if args.drozer:
        run_drozer()        # done
    if args.wifi_proxy:
        toggle_proxy()
    if args.ssl_pinning or type(args.ssl_pinning) is str:
        disable_ssl_pinning(package_name=args.ssl_pinning)  # done
    if args.root_detection or type(args.root_detection) is str:
        disable_root_detection(package_name=args.root_detection)  # done
    #if args.start_appmon or type(args.start_appmon) is str:
    #    start_appmon(package_name=args.start_appmon)
